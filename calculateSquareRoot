.data

float: 		.asciiz "Enter a positive floating number that will have square root taken\n"
errmesg: 	.asciiz "Number was not positive; please enter a positive number\n"
newline: 	.asciiz "\n"
float0: 	.double 0.0
float1: 	.double 1.0
floatd1: 	.double 0.1
floatd5: 	.double 0.5

.text

	# Main method
	la $s0, float0
	l.d $f30, ($s0)
	la $s1, float1
	l.d $f2, ($s1)
	la $s2, floatd1
	l.d $f28, ($s2)
	
	la $a0,float
	li $v0,4
	syscall
	
	# Ask the user for the number they wish to find the square root for and check to make sure it isn't a negative number.
chkin:	li $v0, 7 		# Ask the user for the double floating point input they wish to use.
	syscall
	
	la $a0,newline 		# Create a new line to make it easier to read.
	li $v0,4
	syscall
	
	c.le.d $f0,$f30 	# If the number is not greater than 0, then reenter positive number
	bc1t errmsg
	
	j cont

	# Show the user an error message if they try to find the square root of a negative number.
errmsg:	la $a0,errmsg
	li $v0,4
	syscall
	j chkin
	
	
cont:	c.eq.d $f0, $f4
	bc1t done
	c.lt.d $f4,$f0
	bc1t inc
	
	mul.d $f6,$f30,$f30
	c.lt.d $f0,$f6
	bc1t dec
	j cont2
	
	# Increment until you go one over the near perfect square number
inc:	add.d $f30,$f30, $f2
	mul.d $f4,$f30,$f30
	j cont
	
	# Counter the increment to get the near perfect square number without going over.
dec:	sub.d $f30, $f30,$f2
	mov.d $f24, $f30
	
	addi $t2, $0, 0
	addi $t3, $0,9

cont2:	addi $t2,$t2,1
	bgt $t2,$t3, check
	add.d $f30, $f30, $f28
	mul.d $f26, $f30, $f30
	c.lt.d $f26,$f0
	bc1t cont2
	
	sub.d $f30, $f30,$f28
	
	# Increasing the decimal numbers and square the new number.
check:	la $s1, floatd5
	l.d $f2, ($s1)
	la $s2, float1
	l.d $f28, ($s2)
	
	add.d $f30, $f30, $f2
	add.d $f24, $f24, $f28
	
	c.le.d $f24,$f30
	bc1f printc
	mov.d $f30,$f24	
	j done
	
	# Change the answer from a float to a integer.
printc:	sub.d $f24, $f24, $f28
	mov.d $f30, $f24

done:	cvt.w.d $f30, $f30
	mfc1.d $t0, $f30
	
	li $v0, 1
	move $a0, $t0
	syscall
	li $v0, 10
	syscall