#Nathaniel Warren
#PA3P3


.data

float : .asciiz "Enter a positive floating number that will have square root taken\n"
errormess : .asciiz "Number was not positive; please try again\n"
newline: .asciiz "\n"
floatzero: .double 0.0
floatone: .double 1.0
floatp1: .double 0.1
floatp5: .double 0.5

.text
	la $s0, floatzero
	l.d $f30, ($s0) #will be result
	la $s1, floatone
	l.d $f2, ($s1) #used in incrementations
	la $s2, floatp1
	l.d $f28, ($s2)
	
	la $a0,float #print message
	li $v0,4
	syscall
	 
checkinput:	
	li $v0, 7 #accepting double floating point input from user
	syscall
	# not needed because floating point is in $f0-$f2 move $t0, $v0
	# x is in $f0 and $f1
	
	la $a0,newline #making space
	li $v0,4
	syscall
	
	c.le.d $f0,$f30 #if number is not greater than 0 then reenter positive number
	bc1t errormessage
	
	j continue
errormessage:
		la $a0,errormess #print error message if user didnt input pos number
		li $v0,4
		syscall
		j checkinput #go back to accept input

continue:
	
	c.eq.d $f0, $f4 # when the number entered is equal to the multiplied whole number
	#we are dont; have exact matching
	bc1t done
	#else we are going to go and increment (multipling Result x X and store in result)
	c.lt.d $f4,$f0
	bc1t increment
	
	mul.d $f6,$f30,$f30 
	c.lt.d $f0,$f6
	bc1t decrement #we are finished and we need to decrement
	#j continue2
	#otherwise we need to get approximation and round
	
	
increment:
	add.d $f30,$f30, $f2 #result+1
	mul.d $f4,$f30,$f30 #result*result and store in f4 as total number
	j continue
	
decrement:
	sub.d $f30, $f30,$f2
	mov.d $f24, $f30
	
	addi $t2, $0, 0 #i=0
	addi $t3, $0,9 #continue2 limit of looping i<5
continue2:
	addi $t2,$t2,1
	bgt $t2,$t3, check #checking for loop; if t2 is greater than, we need to check the number computed
	#and we need to round correctly
	#otherwise, continue to compute the tenth space (.x)
	add.d $f30, $f30, $f28 #adding reult+0.1
	mul.d $f26, $f30, $f30 
	c.lt.d $f26,$f0 #if multiplication of new number is less than the original root number, continue for loop
	bc1t continue2
	#otherwise we are done and we need to decrement by one so our answer is accurate
	sub.d $f30, $f30,$f28
	
check:
	#reinstantiating f2 and f28 so we can round correctly
	la $s1, floatp5
	l.d $f2, ($s1)
	la $s2, floatone
	l.d $f28, ($s2)
	
	add.d $f30, $f30, $f2 #result + 0.5
	add.d $f24, $f24, $f28 #c+1
	
	c.le.d $f24,$f30
	bc1f printc #if f24 is less than or equal to f30 we need to just print c (result not rounded)
	#otherwise print rounded number
	mov.d $f30,$f24	
	j done
	
printc:
	sub.d $f24, $f24, $f28 #must decrement so answer is accurate
	mov.d $f30, $f24

done:
	#converting floating point to an integer
	cvt.w.d $f30, $f30
	mfc1.d $t0, $f30
	
	#printing final integer result
	li $v0, 1
	move $a0, $t0
	syscall
	li $v0, 10
	syscall
